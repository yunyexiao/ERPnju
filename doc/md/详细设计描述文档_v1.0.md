# 灯具进销存管理系统详细设计描述文档_v1.0
## v1.0 框架
### 南京大学16级软件学院软工二大作业Orz组  
---
变更记录
---
|修改人员|日期|变更原因|版本号|
|:--|:--|:--|:--|
|钱美缘|2017.10.30|文档结构框架|v1.0|

目录
---

## 1 引言
### 1.1 编制目的
本报告详细完成对连锁商店管理系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。  
本报告面向开发人员、测试人员及最终用户而编写，是了解系统的导航。  

### 1.2 词汇表
|词汇名称|词汇含义|备注|
|---|---|---|
|ERP|进销存管理系统|无|

### 1.3 参考资料
* 灯具进销存系统用例文档_v2.0
* 灯具进销存系统需求规格说明文档_v2.1
* 灯具进销存系统体系结构设计文档_v2.1  

## 2 产品概述
参考灯具进销存系统用例文档和灯具进销存需求规格说明文档中对产品的概括描述。  

## 3 体系结构设计概述 
参考灯具进销存系统体系结构设计文档中对体系结构设计的描述。  

## 4 结构视角
### 4.1 业务逻辑层的分解
业务逻辑层的开发包图参见软件体系结构设计文档图4-1-1。  

<!--以下为格式示例，给各位复制粘贴用
#### 4.1.0 xxxBL模块
#### 4.1.0.1 模块概述
BL模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。  
BL模块的职责及接口参见体系结构设计文档。  

#### 4.1.0.2 整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层和业务逻辑层之间，我们添加___接口。业务逻辑层和数据层之间添加___接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了__Controller，这样__Controller会对__的业务逻辑处理委托给__对象。__PO是作为____的持久化对象添加到设计模型中去的。…………(后面的自己补充)   
<此处省略一张图>
<此处省略一张表>

#### 4.1.0.3 模块内部类的接口规范

#### 4.1.0.4 业务逻辑层的动态模型

-->
#### 4.1.0 initBL模块
#### 4.1.0.1 模块概述
initBL模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。  
initBL模块的职责及接口参见体系结构设计文档。  

#### 4.1.0.2 整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层和业务逻辑层之间，我们添加initBLService接口。业务逻辑层和数据层之间添加initDataService接口。initPO是作为期初数据的持久化对象添加到设计模型中去的。在期初建账的时候，InitBL需要知道上一期末的商品信息、客户信息、账户信息等，因此需要CommodityInfo、AccountInfo、CustomerInfo、CategoryInfo接口获取这些信息。  
InitBL模块的设计如图4-1-0-1所示  
![](doc/img/DesignDiagrams/InitBLClass.png)  
<center>图4-1-0-1  InitBL模块各个类的设计</center>  
InitBL模块的各个类的职责如表4-1-0-1所示   
<center>表4-1-0-1  InitBL模块各个类的职责</center>  

|模块|职责|
|---|---|
|InitBL|负责实现期初建账界面所需要的服务|

#### 4.1.0.3 模块内部类的接口规范
InitBL的接口规范如表4-1-0-3所示  
<table>
<caption>表4-1-0-3 InitBL模块的接口规范 </caption>  
    <tr>
        <td colspan="3"><div class="text" style=" text-align:center;">提供的服务（供接口）</div></td>
    </tr>
    <tr>
        <td rowspan="3">Init.create</td>
        <td>语法</td>
        <td>public boolean create()</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动期初建账定任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>保存期初建账结果，持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Init.check</td>
        <td>语法</td>
        <td>public InitVO check(string year)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>期初建账已完成</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查询结果</td>
    </tr>
</table>

<table>
    <tr>
        <td colspan="2"><div class="text" style=" text-align:center;">需要的接口（需接口）</td>
    </tr>
    <tr>
        <td>服务名</td>
        <td>服务</td>
    </tr>
    <tr>
        <td>InitDataService.get(string year)</td>
        <td>得到对应年度的持久化InitPO记录</td>
    </tr>
    <tr>
        <td>InitDataService.add(InitPO ipo)</td>
        <td>添加单一持久化InitPO记录</td>
    </tr>
    <tr>
        <td>CategoryInfo.get()</td>
        <td>根据关键字获取多个持久化CategoryPO记录</td>
    </tr>
    <tr>
        <td>CommodityInfo.get()</td>
        <td>根据关键字获取多个持久化CustomerPO记录</td>
    </tr>
    <tr>
        <td>CustomerInfo.get()</td>
        <td>根据关键字获取多个持久化CustomerPO记录</td>
    </tr>
    <tr>
        <td>AccountInfo.get()</td>
        <td>根据关键字获取多个持久化AccountPO记录</td>
    </tr>
</table>

#### 4.1.0.4 业务逻辑层的动态模型
图4-1-0-2表明了进销存管理系统中，查看期初信息的业务逻辑处理的相关对象之间的协作。  
![](doc/img/DesignDiagrams/InitBLModel1.png)  
<center>图4-1-0-2  查看往期期初信息的顺序图</center>
图4-1-0-3表明了进销存管理系统中，期初建账的业务逻辑处理的相关对象之间的协作。  
![](doc/img/DesignDiagrams/InitBLModel2.png)  
<center>图4-1-0-3  期初建账的顺序图</center>
如图4-1-0-4所示的状态图描述了InitBL对象在执行查看期初信息任务时的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果check方法被UI调用，进入Input状态，如果用户输入正确格式的年份，进入showInitInfo状态，之后等待用户操作进入结束状态   
![](doc/img/DesignDiagrams/InitBLModel3.png)  
<center>图4-1-0-4  InitBL对象执行查看期初信息状态图</center>
如图4-1-0-5所示的状态图描述了InitBL对象在执行期初建账任务的生存期间的状态序列，引起转移的事件和因状态转移而伴随的动作。如果add方法被UI调用，进入check状态，系统依次调用CommodityInfo、AccountInfo、CustomerInfo、CategoryInfo接口中的get方法获取信息，如果信息不全则进入建账失败的fail状态，否则进入save状态，之后退出期初建账过程进入结束状态。  
![](doc/img/DesignDiagrams/InitBLModel4.png)  
<center>图4-1-0-5  InitBL对象执行期初建账状态图</center>

#### 4.1.0 LogBL模块
#### 4.1.0.1 模块概述
BL模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。  
BL模块的职责及接口参见体系结构设计文档。  

#### 4.1.0.2 整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层和业务逻辑层之间，我们添加LogBLService接口。业务逻辑层和数据层之间添加LogDataService接口。LogPO是作为操作信息的持久化对象添加到设计模型中去的。  
LogBL模块的设计如图4-1-0-1所示  
![](doc/img/DesignDiagrams/LogBLClass.png)  
<center>图4-1-0-1  LogBL模块各个类的设计</center>  
LogBL模块的各个类的职责如表4-1-0-1所示   
<center>表4-1-0-1  LogBL模块各个类的职责</center>  

|模块|职责|
|---|---|
|LogBL|负责实现查看日志界面所需要的服务|

#### 4.1.0.3 模块内部类的接口规范
InitBL的接口规范如表4-1-0-3所示  
<table>
<caption>表4-1-0-2 Logbl模块的接口规范 </caption>  
    <tr>
        <td colspan="3"><div class="text" style=" text-align:center;">提供的服务（供接口）</div></td>
    </tr>
    <tr>
        <td rowspan="3">Log.lookUp</td>
        <td>语法</td>
        <td>public String[][] lookUp(string start_time, string end_time)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>操作人员已被授权</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回所选择时间范围内的单据信息</td>
    </tr>
    <tr>
        <td rowspan="3">Log.getLogInfo()</td>
        <td>语法</td>
        <td>public String[][] getLogInfo()</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>操作人员已被授权</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回所有登录信息</td>
    </tr>
    <tr>
        <td rowspan="3">Log.createLogInfo(LogVO logInfo)</td>
        <td>语法</td>
        <td>public boolean createLogInfo(LogVO logInfo)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>操作人员已被授权</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回操作信息是否添加成功</td>
    </tr>
</table>
<table>
    <tr>
        <td colspan="2">需要的接口（需接口）</td>
    </tr>
    <tr>
        <td>服务名</td>
        <td>服务</td>
    </tr>
    <tr>
        <td>LogDataService.getByTime(string start_time, string end_time)</td>
        <td>得到多个持久化LogPO记录</td>
    </tr>
    <tr>
        <td>LogDataService.getAll()</td>
        <td>得到全部持久化LogPO记录</td>
    </tr>
    <tr>
        <td>LogDataService.addLog(LogPO logInfo)</td>
        <td>增加一条操作记录并持久化</td>
    </tr>
</table>
#### 4.1.0.4 业务逻辑层的动态模型
图4-1-0-2表明了进销存管理系统中，查询操作日志的业务逻辑处理的相关对象之间的协作。  
![](doc/img/DesignDiagrams/LogBLModel1.png)  
<center>图4-1-0-2  查询操作日志的顺序图</center>  
图4-1-0-3表明了进销存管理系统中，增加操作记录的业务逻辑处理的相关对象之间的协作。  
![](doc/img/DesignDiagrams/LogBLModel2.png)  
<center>图4-1-0-3  增加操作记录的顺序图</center>  
如图4-1-0-4所示的状态图描述了LogBL对象在执行查询操作日志任务时的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果lookUp方法被UI调用，进入getInput状态获取用户选择的起始日期和结束日期，得到查询结果后进入show状态显示查询结果，此时还可以调用lookUp方法再次进行查询操作。show状态后自动进入结束状态。  
![](doc/img/DesignDiagrams/LogBLModel3.png)  
如图4-1-0-4所示的状态图描述了LogBL对象在执行增加操作记录任务时的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果createLogInfo方法被其他BL模块调用，进入getInfo状态获取操作信息，再进入addInfo状态添加LogVO并持久化，成功后自动进入结束状态。  
![](doc/img/DesignDiagrams/LogBLModel4.png)  

#### 4.1.0 CategoryBL模块
#### 4.1.0.1 模块概述
CategoryBL模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。  
CategoryBL模块的职责及接口参见体系结构设计文档。  

#### 4.1.0.2 整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层和业务逻辑层之间，我们添加CategoryBLService接口。业务逻辑层和数据层之间添加CategoryDataService接口。此外，CategoryBL还应提供getCategoryInfo接口供BL层其他模块使用。CategoryPO是作为操作信息的持久化对象添加到设计模型中去的。    
CategoryBL模块的设计如图4-1-0-1所示  
![](doc/img/DesignDiagrams/CategoryBLClass.png)  
<center>图4-1-0-1  CategoryBL模块各个类的设计</center>  
CategoryBL模块的各个类的职责如表4-1-0-1所示   
<center>表4-1-0-1  CategoryBL模块各个类的职责</center>  

|模块|职责|
|---|---|
|CategoryBL|负责实现商品分类管理所需要的服务|

#### 4.1.0.3 模块内部类的接口规范

#### 4.1.0.4 业务逻辑层的动态模型

#### 4.1.?1! CommodityBL模块

#### 4.1.?1!.1 模块概述  
  
CommodityBL模块承担的需求参见需求规格说明文档功能需求及相关非公功能需求。  
CommodityBL模块的职责和接口详见体系结构设计文档中表13。  

#### 4.1.?1!.2 整体结构  
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层与业务逻辑层之间，我们添加了BLService.CommodityBLService接口。业务逻辑层和数据层之间我们添加了DataService.CommodityDataService接口。PO.CommodityPO是作为商品的持久化对象而添加到设计模型中去的。  
CommodityBL模块的设计如图4-1-?1!-1所示。  
![](doc/img/DesignDiagrams/CommodityModule.png)  
图4-1-?1!-1 CommodityBL模块各个类的设计  

CommodityBL模块各个类的职责如表4-1-?1!-1所示。  
表4-1-?1!-1  

|模块|职责|
|:---|:---|
|CommodityBL|负责商品管理界面所需要的服务|

#### 4.1.?1!.3 模块内部类的接口规范

CommodityBL的接口规范如表4-1-?1!-2所示。  
表4-1-?1!-2  
<table>
    <tr>
        <td colspan="3"><strong><div class="text" style=" text-align:center;">提供的服务（供接口）</div></strong></td>
    </tr>
    <tr>
        <td rowspan="3">Commodity.getInfo</td>
        <td>语法</td>
        <td>public CommodityVO getInfo(string name)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动商品管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查询商品信息的结果</td>
    </tr>
    <tr>
        <td rowspan="3">Commodity.add</td>
        <td>语法</td>
        <td>public ResultMessage add(CommodityVO com_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动商品管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>增加新商品，持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Commodity.updateInfo</td>
        <td>语法</td>
        <td>public ResultMessage updateInfo(CommodityVO com_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>商品存在</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Commodity.delete</td>
        <td>语法</td>
        <td>public ResultMessage delete(string name)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>商品存在</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>删除商品，返回删除信息，持久化更新所涉及的数据</td>
    </tr>
    
     <tr>
        <td rowspan="3">Commodity.lookupStock</td>
        <td>语法</td>
        <td>public ArrayList<StockVO> lookupStock(string begin_time, string end_time)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>操作人员已被授权</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查看的商品库存结果</td>
    </tr>
    
     <tr>
        <td rowspan="3">Commodity.dayCheckStock</td>
        <td>语法</td>
        <td>public ArrayList<StockCommodityVO> dayCheckStock()</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>操作人员已被授权</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回所查询库存情况</td>
    </tr>
</table>

#### 4.1.?1!.4 业务逻辑层的动态模型

图4-1-?1!-2表明了在进销存系统中，在增加一个商品的过程中输入一个商品信息之后，商品管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CommodityAddSd.png)  
图4-1-?1!-2  

图4-1-?1!-3表明了在进销存系统中，在删除一个商品的过程中输入一个商品ID之后，商品管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CommodityDelSd.png)  
图4-1-?1!-3  

图4-1-?1!-4表明了在进销存系统中，在修改一个商品的过程中输入一个商品信息之后，商品管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CommodityUpdateSd.png)  
图4-1-?1!-4  

图4-1-?1!-5表明了在进销存系统中，在查询一个商品的过程中输入一个商品信息之后，商品管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CommodityFindSd.png)  
图4-1-?1!-5  

如图4-1-?1!-6所示的状态图描述了CommodityBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果add方法被UI调用，CommodityBL进入waitForInput状态，之后通过vaild进入newCommodity状态，最后通过confirm进入结束状态。在waitForInput状态也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/CommodityAddStm.png)  
图4-1-?1!-6  

如图4-1-?1!-7所示的状态图描述了CommodityBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果getInfo方法被ui调用，CommodityBL进入showInfo状态，最后通过confirm进入结束状态。在showInfo状态下也可以通过return直接进入结束状态。  
![](doc/img/DesignDiagrams/CommodityDelStm.png)  
图4-1-?1!-7  

如图4-1-?1!-8所示的状态图描述了CommodityBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果update方法被ui调用，CommodityBL进入waitForInput状态，之后通过valid进入CommodityInfo状态，最后通过confirm进入结束状态。在waitForInput状态下也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/CommodityUpdateStm.png)  
图4-1-?1!-8  

如图4-1-?1!-9所示的状态图描述了CommodityBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果findById/findByName方法被ui调用，CommodityBL进入waitForInput状态，之后通过valid进入CommodityInfo状态，最后通过exit进入结束状态。在waitForInput状态下，也可以通过cancel进入结束状态。在CommodityInfo状态下可以通过再次调用findById/findByName方法进入waitForInput状态。  
![](doc/img/DesignDiagrams/CommodityFindStm.png)  
图4-1-?1!-9  


#### 4.1.?2! AccountBL模块

#### 4.1.?2!.1 模块概述  
 
AccountBL模块承担的需求参见需求规格说明文档功能需求及相关非公功能需求。  
AccountBL模块的职责和接口详见体系结构设计文档。  

#### 4.1.?2!.2 整体结构  
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层与业务逻辑层之间，我们添加了BLService.AccountBLService接口。业务逻辑层和数据层之间我们添加了DataService.AccountDataService接口。PO.AccountPO是作为账户的持久化对象而添加到设计模型中去的。  
AccountBL模块的设计如图4-1-?2!-1所示。  
![](doc/img/DesignDiagrams/AccountModule.png)  
图4-1-?2!-1 AccountBL模块各个类的设计  

AccountBL模块各个类的职责如表4-1-?2!-1所示。  
表4-1-?2!-1  

|模块|职责|
|:---|:---|
|AccountBL|负责账户管理界面所需要的服务|

#### 4.1.?2!.3 模块内部类的接口规范

AccountBL的接口规范如表4-1-?2!-2所示。  
表4-1-?2!-2  
<table>
    <tr>
        <td colspan="3"><strong><div class="text" style=" text-align:center;">提供的服务（供接口）</div></strong></td>
    </tr>
    <tr>
        <td rowspan="3">Account.getAccountInfo</td>
        <td>语法</td>
        <td>public AccountVO getAccountInfo(string name)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>登录成功并启动银行账户管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查询的银行账户信息的结果</td>
    </tr>
    <tr>
        <td rowspan="3">Account.addAccount</td>
        <td>语法</td>
        <td>public ResultMessage addAccount(AccountVO acc_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>登录成功并启动银行账户管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>增加新的银行账户，持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Account.updateAccountInfo</td>
        <td>语法</td>
        <td>public ResultMessage updateAccountInfo(AccountVO acc_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>此银行账户已创建</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Account.deleteAccount</td>
        <td>语法</td>
        <td>public ResultMessage deleteAccount(string name)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>次银行账户已添加到系统中</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>删除此银行账户，持久化更新所涉及的数据</td>
    </tr>
</table>

#### 4.1.?2!.4 业务逻辑层的动态模型

图4-1-?2!-2表明了在进销存系统中，在增加一个账户的过程中输入一个账户信息之后，账户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/AccountAddSd.png)  
图4-1-?2!-2  

图4-1-?2!-3表明了在进销存系统中，在删除一个账户的过程中输入一个账户ID之后，账户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/AccountDelSd.png)  
图4-1-?2!-3  

图4-1-?2!-4表明了在进销存系统中，在修改一个账户的过程中输入一个账户信息之后，账户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/AccountUpdateSd.png)  
图4-1-?2!-4  

图4-1-?2!-5表明了在进销存系统中，在查询一个账户的过程中输入一个账户信息之后，账户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/AccountFindSd.png)  
图4-1-?2!-5  

如图4-1-?2!-6所示的状态图描述了AccountBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果add方法被UI调用，AccountBL进入waitForInput状态，之后通过vaild进入newAccount状态，最后通过confirm进入结束状态。在waitForInput状态也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/AccountAddStm.png)  
图4-1-?2!-6  

如图4-1-?2!-7所示的状态图描述了AccountBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果getInfo方法被ui调用，AccountBL进入showInfo状态，最后通过confirm进入结束状态。在showInfo状态下也可以通过return直接进入结束状态。  
![](doc/img/DesignDiagrams/AccountDelStm.png)  
图4-1-?2!-7  

如图4-1-?2!-8所示的状态图描述了AccountBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果update方法被ui调用，AccountBL进入waitForInput状态，之后通过valid进入AccountInfo状态，最后通过confirm进入结束状态。在waitForInput状态下也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/AccountUpdateStm.png)  
图4-1-?2!-8  

如图4-1-?2!-9所示的状态图描述了AccountBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果findById/findByName方法被ui调用，AccountBL进入waitForInput状态，之后通过valid进入AccountInfo状态，最后通过exit进入结束状态。在waitForInput状态下，也可以通过cancel进入结束状态。在AccountInfo状态下可以通过再次调用findById/findByName方法进入waitForInput状态。  
![](doc/img/DesignDiagrams/AccountFindStm.png)  
图4-1-?2!-9  


#### 4.1.?3! CustomerBL模块

#### 4.1.?3!.1 模块概述  
 
CustomerBL模块承担的需求参见需求规格说明文档功能需求及相关非公功能需求。  
CustomerBL模块的职责和接口详见体系结构设计文档。  

#### 4.1.?3!.2 整体结构  
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层与业务逻辑层之间，我们添加了BLService.CustomerBLService接口。业务逻辑层和数据层之间我们添加了DataService.CustomerDataService接口。PO.CustomerPO是作为顾客的持久化对象而添加到设计模型中去的。  
CustomerBL模块的设计如图4-1-?3!-1所示。  
![](doc/img/DesignDiagrams/CustomerModule.png)  
图4-1-?3!-1 CustomerBL模块各个类的设计  

CustomerBL模块各个类的职责如表4-1-?3!-1所示。  
表4-1-?3!-1  

|模块|职责|
|:---|:---|
|CustomerBL|负责顾客管理界面所需要的服务|

#### 4.1.?3!.3 模块内部类的接口规范

CustomerBL的接口规范如表4-1-?3!-2所示。  
表4-1-?3!-2  
<table>
    <tr>
        <td colspan="3"><strong><div class="text" style=" text-align:center;">提供的服务（供接口）</div></strong></td>
    </tr>
    <tr>
        <td rowspan="3">Customer.getCustomerInfo</td>
        <td>语法</td>
        <td>public CustomerVO getCustomerInfo(string id)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动客户管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查询的客户信息的结果</td>
    </tr>
    <tr>
        <td rowspan="3">Customer.addCustomer</td>
        <td>语法</td>
        <td>public ResultMessage addCustomer(CustomerVO cus_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动客户管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>增加新的客户，持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Customer.updateCustomerInfo</td>
        <td>语法</td>
        <td>public ResultMessage updateCustomerInfo(CustomerVO cus_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>客户已添加到系统中</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Customer.deleteCustomer</td>
        <td>语法</td>
        <td>public ResultMessage deleteCustomer(string id)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>客户已添加到系统中</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>删除特定客户，持久化更新所涉及的数据</td>
    </tr>
</table>

#### 4.1.?3!.4 业务逻辑层的动态模型

图4-1-?3!-2表明了在进销存系统中，在增加一个顾客的过程中输入一个顾客信息之后，顾客管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CustomerAddSd.png)  
图4-1-?3!-2  

图4-1-?3!-3表明了在进销存系统中，在删除一个顾客的过程中输入一个顾客ID之后，顾客管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CustomerDelSd.png)  
图4-1-?3!-3  

图4-1-?3!-4表明了在进销存系统中，在修改一个顾客的过程中输入一个顾客信息之后，顾客管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CustomerUpdateSd.png)  
图4-1-?3!-4  

图4-1-?3!-5表明了在进销存系统中，在查询一个顾客的过程中输入一个顾客信息之后，顾客管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CustomerFindSd.png)  
图4-1-?3!-5  

如图4-1-?3!-6所示的状态图描述了CustomerBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果add方法被UI调用，CustomerBL进入waitForInput状态，之后通过vaild进入newCustomer状态，最后通过confirm进入结束状态。在waitForInput状态也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/CustomerAddStm.png)  
图4-1-?3!-6  

如图4-1-?3!-7所示的状态图描述了CustomerBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果getInfo方法被ui调用，CustomerBL进入showInfo状态，最后通过confirm进入结束状态。在showInfo状态下也可以通过return直接进入结束状态。  
![](doc/img/DesignDiagrams/CustomerDelStm.png)  
图4-1-?3!-7  

如图4-1-?3!-8所示的状态图描述了CustomerBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果update方法被ui调用，CustomerBL进入waitForInput状态，之后通过valid进入CustomerInfo状态，最后通过confirm进入结束状态。在waitForInput状态下也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/CustomerUpdateStm.png)  
图4-1-?3!-8  

如图4-1-?3!-9所示的状态图描述了CustomerBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果findById/findByName方法被ui调用，CustomerBL进入waitForInput状态，之后通过valid进入CustomerInfo状态，最后通过exit进入结束状态。在waitForInput状态下，也可以通过cancel进入结束状态。在CustomerInfo状态下可以通过再次调用findById/findByName方法进入waitForInput状态。  
![](doc/img/DesignDiagrams/CustomerFindStm.png)  
图4-1-?3!-9  


#### 4.1.?4! UserBL模块

#### 4.1.?4!.1 模块概述  
 
UserBL模块承担的需求参见需求规格说明文档功能需求及相关非公功能需求。  
UserBL模块的职责和接口详见体系结构设计文档。  

#### 4.1.?4!.2 整体结构  
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层与业务逻辑层之间，我们添加了BLService.UserBLService接口。业务逻辑层和数据层之间我们添加了DataService.UserDataService接口。PO.UserPO是作为用户的持久化对象而添加到设计模型中去的。  
UserBL模块的设计如图4-1-?4!-1所示。  
![](doc/img/DesignDiagrams/UserModule.png)  
图4-1-?4!-1 UserBL模块各个类的设计  

UserBL模块各个类的职责如表4-1-?4!-1所示。  
表4-1-?4!-1  

|模块|职责|
|:---|:---|
|UserBL|负责用户管理界面所需要的服务|

#### 4.1.?4!.3 模块内部类的接口规范

UserBL的接口规范如表4-1-?4!-2所示。  
表4-1-?4!-2  
<table>
    <tr>
        <td colspan="3"><strong><div class="text" style=" text-align:center;">提供的服务（供接口）</div></strong></td>
    </tr>
    <tr>
        <td rowspan="3">User.getUserInfo</td>
        <td>语法</td>
        <td>public UserVO getUserInfo(string id)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动系统用户管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查询的系统用户的结果</td>
    </tr>
    <tr>
        <td rowspan="3">User.addUser</td>
        <td>语法</td>
        <td>public ResultMessage addUser(UserVO user_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动系统用户管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>增加新的系统用户，持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">User.updateUserInfo</td>
        <td>语法</td>
        <td>public ResultMessage updateUserInfo(UserVO user_info)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>用户已添加到系统中</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">User.deleteUser</td>
        <td>语法</td>
        <td>public ResultMessage deleteUser(string id)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>用户已添加到系统中</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>删除特定系统用户，持久化更新所涉及的数据</td>
    </tr>
</table>

#### 4.1.?4!.4 业务逻辑层的动态模型

图4-1-?4!-2表明了在进销存系统中，在增加一个用户的过程中输入一个用户信息之后，用户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/UserAddSd.png)  
图4-1-?4!-2  

图4-1-?4!-3表明了在进销存系统中，在删除一个用户的过程中输入一个用户ID之后，用户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/UserDelSd.png)  
图4-1-?4!-3  

图4-1-?4!-4表明了在进销存系统中，在修改一个用户的过程中输入一个用户信息之后，用户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/UserUpdateSd.png)  
图4-1-?4!-4  

图4-1-?4!-5表明了在进销存系统中，在查询一个用户的过程中输入一个用户信息之后，用户管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/UserFindSd.png)  
图4-1-?4!-5  

如图4-1-?4!-6所示的状态图描述了UserBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果add方法被UI调用，UserBL进入waitForInput状态，之后通过vaild进入newUser状态，最后通过confirm进入结束状态。在waitForInput状态也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/UserAddStm.png)  
图4-1-?4!-6  

如图4-1-?4!-7所示的状态图描述了UserBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果getInfo方法被ui调用，UserBL进入showInfo状态，最后通过confirm进入结束状态。在showInfo状态下也可以通过return直接进入结束状态。  
![](doc/img/DesignDiagrams/UserDelStm.png)  
图4-1-?4!-7  

如图4-1-?4!-8所示的状态图描述了UserBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果update方法被ui调用，UserBL进入waitForInput状态，之后通过valid进入UserInfo状态，最后通过confirm进入结束状态。在waitForInput状态下也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/UserUpdateStm.png)  
图4-1-?4!-8  

如图4-1-?4!-9所示的状态图描述了UserBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果findById/findByName方法被ui调用，UserBL进入waitForInput状态，之后通过valid进入UserInfo状态，最后通过exit进入结束状态。在waitForInput状态下，也可以通过cancel进入结束状态。在UserInfo状态下可以通过再次调用findById/findByName方法进入waitForInput状态。  
![](doc/img/DesignDiagrams/UserFindStm.png)  
图4-1-?4!-9  


#### 4.1.?5! CategoryBL模块

#### 4.1.?5!.1 模块概述  
 
CategoryBL模块承担的需求参见需求规格说明文档功能需求及相关非公功能需求。  
CategoryBL模块的职责和接口详见体系结构设计文档。  

#### 4.1.?5!.2 整体结构  
  
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们添加了接口。比如展示层与业务逻辑层之间，我们添加了BLService.CategoryBLService接口。业务逻辑层和数据层之间我们添加了DataService.CategoryDataService接口。PO.CategoryPO是作为商品分类的持久化对象而添加到设计模型中去的。  
CategoryBL模块的设计如图4-1-?5!-1所示。  
![](doc/img/DesignDiagrams/CategoryModule.png)  
图4-1-?5!-1 CategoryBL模块各个类的设计  

CategoryBL模块各个类的职责如表4-1-?5!-1所示。  
表4-1-?5!-1  

|模块|职责|
|:---|:---|
|CategoryBL|负责商品分类管理界面所需要的服务|

#### 4.1.?5!.3 模块内部类的接口规范

CategoryBL的接口规范如表4-1-?5!-2所示。  
表4-1-?5!-2  
<table>
    <tr>
        <td colspan="3"><strong><div class="text" style=" text-align:center;">提供的服务（供接口）</div></strong></td>
    </tr>
    <tr>
        <td rowspan="3">Category.getInfo</td>
        <td>语法</td>
        <td>public CategoryVO getInfo(string name)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动商品分类管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>返回查询商品分类信息的结果</td>
    </tr>
    <tr>
        <td rowspan="3">Category.add</td>
        <td>语法</td>
        <td>public ResultMessage add(CategoryVO vo)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>启动商品分类管理任务</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>增加新商品分类，持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Category.updateInfo</td>
        <td>语法</td>
        <td>public ResultMessage updateInfo(string oldcato, string newcato)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>商品分类存在</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>持久化更新所涉及的数据</td>
    </tr>
    <tr>
        <td rowspan="3">Category.delete</td>
        <td>语法</td>
        <td>public ResultMessage delete(string name)</td>
    </tr>
    <tr>
        <td>前置条件</td>
        <td>商品分类存在</td>
    </tr>
    <tr>
        <td>后置条件</td>
        <td>删除商品分类，返回删除信息，持久化更新所涉及的数据</td>
    </tr>
</table>

#### 4.1.?5!.4 业务逻辑层的动态模型

图4-1-?5!-2表明了在进销存系统中，在增加一个商品分类的过程中输入一个商品分类信息之后，商品分类管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CategoryAddSd.png)  
图4-1-?5!-2  

图4-1-?5!-3表明了在进销存系统中，在删除一个商品分类的过程中输入一个商品分类ID之后，商品分类管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CategoryDelSd.png)  
图4-1-?5!-3  

图4-1-?5!-4表明了在进销存系统中，在修改一个商品分类的过程中输入一个商品分类信息之后，商品分类管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CategoryUpdateSd.png)  
图4-1-?5!-4  

图4-1-?5!-5表明了在进销存系统中，在查询一个商品分类的过程中输入一个商品分类信息之后，商品分类管理业务逻辑处理的相关的对象之间的协作。  
![](doc/img/DesignDiagrams/CategoryFindSd.png)  
图4-1-?5!-5  

如图4-1-?5!-6所示的状态图描述了CategoryBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果add方法被UI调用，CategoryBL进入waitForInput状态，之后通过vaild进入newCategory状态，最后通过confirm进入结束状态。在waitForInput状态也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/CategoryAddStm.png)  
图4-1-?5!-6  

如图4-1-?5!-7所示的状态图描述了CategoryBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果getInfo方法被ui调用，CategoryBL进入showInfo状态，最后通过confirm进入结束状态。在showInfo状态下也可以通过return直接进入结束状态。  
![](doc/img/DesignDiagrams/CategoryDelStm.png)  
图4-1-?5!-7  

如图4-1-?5!-8所示的状态图描述了CategoryBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果update方法被ui调用，CategoryBL进入waitForInput状态，之后通过valid进入CategoryInfo状态，最后通过confirm进入结束状态。在waitForInput状态下也可以通过cancel直接进入结束状态。  
![](doc/img/DesignDiagrams/CategoryUpdateStm.png)  
图4-1-?5!-8  

如图4-1-?5!-9所示的状态图描述了CategoryBL对象的生存期间的状态序列，引起转移的事件，以及因状态转移而伴随的动作。如果findById/findByName方法被ui调用，CategoryBL进入waitForInput状态，之后通过valid进入CategoryInfo状态，最后通过exit进入结束状态。在waitForInput状态下，也可以通过cancel进入结束状态。在CategoryInfo状态下可以通过再次调用findById/findByName方法进入waitForInput状态。  
![](doc/img/DesignDiagrams/CategoryFindStm.png)  
图4-1-?5!-9  

## 5 依赖视角
